#第五篇	Dalvik VM和JVM的不完全比较 
2015年6月23日21:38:48

毕业之后的第一篇文章，虽然多总结他人的东西，但是自己也是经过思考的东西。一个全新的里程碑，努力学习，争取变得优秀起来，这样才能更好。

我的大宝贝前天晚上可是给我说道了说道，弄得我说都不会话了，╮(╯▽╰)╭，女生的世界理解不了啊，天地可鉴！我可是天天想着她的啊，不过我们会好好的，要用时间来沉淀出美好的东西。

---

git tag -a v0.1 -m "2015年6月21日 感情V0.1版本"

我猜某人看不懂这个命令,谁叫她不听我话，不好好学git呢(*^__^*) 嘻嘻……

---

1. 编译后文件格式不同
	1. JVM：.java-->.class-->.jar
	2. Dalvik VM:.java-->.class-->.dex-->.odex

2. 架构不同
	1. JVM：stack-based(基于栈的架构)
	2. Dalvik VM:register-based(基于寄存器的架构)

	基于寄存器的架构可以做到很好的提前优化，但是代价是代码长度的增加。
3. 字节码文件的不同
	1. JVM：执行.class格式的字节码文件
	2. Dalvik VM:执行.dex格式的字节码文件

4. 运行实例的不同
	1. JVM：

			一个运行时的Java虚拟机(JVM)负责运行一个Java程序。当启动一个Java程序时，
			一个虚拟机实例诞生；当程序关闭退出，这个虚拟机实例也就随之消亡。
			如果在同一台计算机上同时运行多个Java程序，将得到多个Java虚拟机实例，
			每个Java程序都运行于它自己的Java虚拟机实例中。
	2. Dalvik VM:

			Dalvik可以允许多个instance 运行，也就是说每一个Android 的App是独立跑在一个VM中.
			这样做的好处是一个App crash只会影响到自身的VM，不会影响到其他。 
			Dalvik的设计是每一个Dalvik的VM都是Linux下面的一个进程。那么这就需要高效的IPC。
			另外每一个VM是单独运行的好处还有可以动态active/deactive自己的VM而不会影响到其他VM

5. 与操作系统的关系
	1. JVM:
		
			JVM的特点是取底层OS和硬件环境的交集，从而保障这种一致性。而所有应用程序和底层资源的互动，
			一定是依赖JVM的传递和转换来实现。JVM真正实现了一个OS对应用程序运行时管理的所有功能。
			因此，因为运行时中间隔着一个JVM，JVM中的JAVA程序的崩溃，最多导致JVM的崩溃，而不会导致OS崩溃。
	2. Dalvik VM:
		
			每一个Android应用都运行在一个Dalvik虚拟机实例里，而每一个虚拟机实例都是一个独立的进程空间。
			每个进程之间可以通信（IPC，Binder机制实现）。虚拟机的线程机制，内存分配和管理，
			Mutex等等都是依赖底层操作系统而实现的。
			不同的应用在不同的进程空间里运行，当一个虚拟机关闭或意外中止时不会对其它虚拟机造成影响，
			可以最大程度的保护应用的安全和独立运行。
			所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制。
			因此，apk的崩溃，可以直接导致OS崩溃，android手机会因为应用程序死机。

6. DVM特有
	1. dex文件格式可以减少整体文件尺寸，提高I/o操作的类查找速度。但又优化为odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。

		图示：
		
		![](http://pic3.zhimg.com/89004d346270564b26849f54a66ca8b6_b.jpg)


	2. 有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化，库的加载，预制类库和初 始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的诉据提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一 块内存区域。
	
		有关Zygote详解[http://www.cnblogs.com/innost/archive/2011/01/26/1945769.html](http://www.cnblogs.com/innost/archive/2011/01/26/1945769.html)  我可不敢看，现在又看不懂，以后再说吧。